<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Å≠„Åì„Éê„Éà„É´„ÉÅ„É£„É¨„É≥„Ç∏</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }
        #game-container {
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
            text-align: center;
            position: relative; /* For damage effect positioning */
        }
        #battle-screen {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #e7f3ff;
            border-radius: 8px;
        }
        .character {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .character-icon {
            font-size: 4em; /* Slightly larger icons */
            margin-bottom: 5px;
        }
        .hp-bar-container {
            width: 100px;
            height: 15px; /* Slightly thicker HP bar */
            background-color: #ddd;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
            border: 1px solid #bbb; /* Add border */
        }
        .hp-bar {
            height: 100%;
            background-color: #4caf50; /* Green HP */
            width: 100%;
            transition: width 0.5s ease;
            border-radius: 4px 0 0 4px; /* Match container radius */
        }
        .hp-bar.low {
            background-color: #f44336; /* Red HP when low */
        }
        #enemy-hp-bar {
             background-color: #f44336; /* Red HP */
        }
        #question-area {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #fffbe6;
            border-radius: 8px;
            font-size: 1.5em; /* Larger question text */
            min-height: 50px; /* Ensure consistent height */
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px dashed #ccc;
        }
        #options-area {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        .option-button {
            padding: 15px;
            font-size: 1.2em;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .option-button:hover {
            background-color: #45a049;
        }
        .option-button:active {
            background-color: #3e8e41;
        }
        #feedback-area {
            margin-top: 15px;
            font-weight: bold;
            min-height: 25px; /* Ensure space for feedback */
            font-size: 1.1em;
            color: #333;
        }
        #combo-area {
            margin-top: 10px;
            font-size: 1.2em;
            color: #ff9800; /* Orange combo text */
            font-weight: bold;
            min-height: 20px;
        }
        #timer-area {
            margin-top: 10px;
            font-size: 1.1em;
            color: #666;
        }
        #score-area {
            margin-top: 10px;
            font-size: 1.1em;
            color: #333;
        }
        #result-screen, #mode-selection-screen, #stage-selection-screen {
            display: none; /* Initially hidden */
            padding: 20px;
            border-radius: 10px;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin-top: 20px;
            text-align: center;
        }
        #result-screen h2, #mode-selection-screen h2, #stage-selection-screen h2 {
            margin-bottom: 15px;
            color: #333;
        }
         button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #2196F3;
            color: white;
            margin: 5px;
            transition: background-color 0.3s ease;
         }
         button:hover {
             background-color: #1e88e5;
         }
         button:active {
             background-color: #1976d2;
         }
        .mode-button, .stage-button {
            display: block;
            width: 80%;
            margin: 10px auto;
            padding: 15px;
        }
        #bgm-toggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .damage-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            font-weight: bold;
            color: red;
            animation: fadeOut 1s forwards;
            pointer-events: none; /* Prevent interaction */
            z-index: 10; /* Ensure it's above other elements */
            text-shadow: 1px 1px 2px black; /* Add shadow for visibility */
        }
        .critical-damage {
            color: #ff4500; /* OrangeRed for critical */
            font-size: 2.5em; /* Larger for critical */
            animation: fadeOutScale 1s forwards; /* Different animation */
        }

        @keyframes fadeOut {
            from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -100%) scale(1.2); } /* Move up slightly */
        }
        @keyframes fadeOutScale {
            from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -100%) scale(1.5); } /* Move up and scale more */
        }
        /* Responsive Design */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            #game-container {
                padding: 15px;
            }
            .character-icon {
                font-size: 3em;
            }
            #question-area {
                font-size: 1.2em;
            }
            #options-area {
                grid-template-columns: 1fr; /* Stack options vertically */
            }
            .option-button {
                font-size: 1em;
                padding: 12px;
            }
            #bgm-toggle {
                width: 35px;
                height: 35px;
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="mode-selection-screen">
            <h2>„É¢„Éº„ÉâÈÅ∏Êäû</h2>
            <button class="mode-button" onclick="selectMode('grade')">Â≠¶Âπ¥Âà•„É¢„Éº„Éâ</button>
            <button class="mode-button" onclick="selectMode('training')">„Éà„É¨„Éº„Éã„É≥„Ç∞„É¢„Éº„Éâ</button>
            <button onclick="resetGameData()">„Éá„Éº„Çø„É™„Çª„ÉÉ„Éà</button>
        </div>

        <div id="stage-selection-screen">
            <h2>„Çπ„ÉÜ„Éº„Ç∏ÈÅ∏Êäû</h2>
            <button onclick="showModeSelection()">Êàª„Çã</button>
        </div>

        <div id="game-screen" style="display: none;">
            <div id="battle-screen">
                <div class="character" id="player">
                    <span class="character-icon">üê±</span>
                    <span>„Éó„É¨„Ç§„É§„Éº</span>
                    <div class="hp-bar-container">
                        <div class="hp-bar" id="player-hp-bar"></div>
                    </div>
                    <span id="player-hp-text">HP: 100/100</span>
                </div>
                <div id="vs">VS</div>
                <div class="character" id="enemy">
                    <span class="character-icon" id="enemy-icon">‚ùì</span>
                    <span id="enemy-name">„Å¶„Åç</span>
                    <div class="hp-bar-container">
                        <div class="hp-bar" id="enemy-hp-bar"></div>
                    </div>
                    <span id="enemy-hp-text">HP: 100/100</span>
                </div>
            </div>

            <div id="question-area">„Åì„Åì„Å´ÂïèÈ°å„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô</div>
            <div id="timer-area">„ÅÆ„Åì„ÇäÊôÇÈñì: 10Áßí</div>
            <div id="options-area">
                </div>
            <div id="feedback-area"></div>
            <div id="combo-area"></div>
            <div id="score-area">„Çπ„Ç≥„Ç¢: 0</div>
             <button onclick="showModeSelection()">„É¢„Éº„ÉâÈÅ∏Êäû„Å´Êàª„Çã</button>
        </div>

        <div id="result-screen">
            <h2 id="result-title">ÁµêÊûú</h2>
            <p id="result-message"></p>
            <p id="result-score"></p>
            <button onclick="restartGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶ÊåëÊà¶</button>
            <button onclick="showModeSelection()">„É¢„Éº„ÉâÈÅ∏Êäû„Å∏</button>
        </div>
    </div>

    <button id="bgm-toggle" onclick="toggleBGM()">üîä</button>
    <audio id="bgm" loop>
        Your browser does not support the audio element.
    </audio>

    <script>
        // --- ÂÆöÊï∞ÂÆöÁæ© (Constants Definition) ---
        const PLAYER_MAX_HP = 100;
        const BASE_ENEMY_HP = 50;
        const HP_INCREASE_PER_STAGE = 10; // „Çπ„ÉÜ„Éº„Ç∏„Åî„Å®„ÅÆHPÂ¢óÂä†Èáè
        const BASE_DAMAGE = 10;
        const CRITICAL_HIT_CHANCE = 0.1; // 10%
        const CRITICAL_HIT_MULTIPLIER = 2;
        const COMBO_BONUS_MULTIPLIER = 0.1; // 1„Ç≥„É≥„Éú„ÅÇ„Åü„Çä10%„ÉÄ„É°„Éº„Ç∏Â¢ó
        const TIME_LIMIT_SECONDS = 10; // ÂïèÈ°å„Åî„Å®„ÅÆÂà∂ÈôêÊôÇÈñì
        const HP_PENALTY_WRONG = 5; // ‰∏çÊ≠£Ëß£ÊôÇ„ÅÆHP„Éö„Éä„É´„ÉÜ„Ç£
        const HP_PENALTY_TIMEOUT = 10; // ÊôÇÈñìÂàá„ÇåÊôÇ„ÅÆHP„Éö„Éä„É´„ÉÜ„Ç£
        const MAX_GRADE = 6; // ÊúÄÂ§ßÂ≠¶Âπ¥
        const STAGES_PER_GRADE = 5; // 1Â≠¶Âπ¥„ÅÇ„Åü„Çä„ÅÆ„Çπ„ÉÜ„Éº„Ç∏Êï∞
        const TRAINING_PROBLEM_COUNT = 10; // „Éà„É¨„Éº„Éã„É≥„Ç∞„É¢„Éº„Éâ„ÅÆÂïèÈ°åÊï∞
        const NEXT_ACTION_DELAY_MS = 1000; // Ê¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Åæ„Åß„ÅÆÂæÖÊ©üÊôÇÈñì(„Éü„É™Áßí)
        const ENEMY_DEFEATED_DELAY_MS = 1500; // ÊïµÊíÉÁ†¥Âæå„ÅÆÂæÖÊ©üÊôÇÈñì

        // --- „Ç≤„Éº„É†Áä∂ÊÖãÂ§âÊï∞ (Game State Variables) ---
        let playerHp = PLAYER_MAX_HP;
        let enemyHp = BASE_ENEMY_HP;
        let currentEnemyMaxHp = BASE_ENEMY_HP;
        let currentQuestion = "";
        let correctAnswer = 0;
        let options = [];
        let currentCombo = 0;
        let score = 0;
        let timerInterval = null;
        let timeLeft = TIME_LIMIT_SECONDS;
        let currentMode = ''; // 'grade' or 'training'
        let currentGrade = 1; // For grade mode
        let currentStage = 1; // For grade mode
        let stageProgress = {}; // { '1': 3, '2': 1 } means grade 1 cleared up to stage 3, grade 2 up to stage 1
        let trainingProblemsAnswered = 0;
        let trainingCorrectAnswers = 0;

        // --- Êïµ„Ç≠„É£„É©„ÇØ„Çø„Éº„Éá„Éº„Çø (Enemy Character Data) ---
        const enemies = [
            { name: "„Çπ„É©„Ç§„É†", icon: "üíß", minGrade: 1 },
            { name: "„Ç¥„Éñ„É™„É≥", icon: "üë∫", minGrade: 1 },
            { name: "„Çπ„Ç±„É´„Éà„É≥", icon: "üíÄ", minGrade: 2 },
            { name: "„Ç™„Éº„ÇØ", icon: "üëπ", minGrade: 3 },
            { name: "„Éâ„É©„Ç¥„É≥", icon: "üêâ", minGrade: 4 },
            { name: "„Åæ„Åä„ÅÜ", icon: "üòà", minGrade: 5 },
            { name: "ÔºüÔºüÔºü", icon: "üëª", minGrade: 6 } // Higher grade enemy
        ];

        // --- DOMË¶ÅÁ¥† (DOM Elements) ---
        const gameContainer = document.getElementById('game-container');
        const modeSelectionScreen = document.getElementById('mode-selection-screen');
        const stageSelectionScreen = document.getElementById('stage-selection-screen');
        const gameScreen = document.getElementById('game-screen');
        const resultScreen = document.getElementById('result-screen');
        const playerHpBar = document.getElementById('player-hp-bar');
        const playerHpText = document.getElementById('player-hp-text');
        const enemyHpBar = document.getElementById('enemy-hp-bar');
        const enemyHpText = document.getElementById('enemy-hp-text');
        const enemyIcon = document.getElementById('enemy-icon');
        const enemyName = document.getElementById('enemy-name');
        const questionArea = document.getElementById('question-area');
        const optionsArea = document.getElementById('options-area');
        const feedbackArea = document.getElementById('feedback-area');
        const comboArea = document.getElementById('combo-area');
        const timerArea = document.getElementById('timer-area');
        const scoreArea = document.getElementById('score-area');
        const resultTitle = document.getElementById('result-title');
        const resultMessage = document.getElementById('result-message');
        const resultScore = document.getElementById('result-score');
        const bgm = document.getElementById('bgm');
        const bgmToggle = document.getElementById('bgm-toggle');

        // --- BGMÈñ¢ÈÄ£ (BGM Functions) ---
        let isBgmPlaying = false;
        function toggleBGM() {
            if (isBgmPlaying) {
                bgm.pause();
                bgmToggle.textContent = 'üîá';
            } else {
                bgm.play().catch(error => console.log("BGM play failed:", error));
                bgmToggle.textContent = 'üîä';
            }
            isBgmPlaying = !isBgmPlaying;
        }

        // --- „Éá„Éº„ÇøÁÆ°ÁêÜ (Data Management) ---
        function loadGameData() {
            const savedProgress = localStorage.getItem('nekoBattleProgress');
            if (savedProgress) {
                stageProgress = JSON.parse(savedProgress);
            } else {
                stageProgress = {};
                for (let i = 1; i <= MAX_GRADE; i++) {
                    stageProgress[i] = 0;
                }
            }
            for (let i = 1; i <= MAX_GRADE; i++) {
                if (!(i in stageProgress)) {
                    stageProgress[i] = 0;
                }
            }
        }

        function saveGameData() {
            localStorage.setItem('nekoBattleProgress', JSON.stringify(stageProgress));
        }

        function resetGameData() {
            if (confirm("Êú¨ÂΩì„Å´„Ç≤„Éº„É†„Éá„Éº„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü„ÇØ„É™„Ç¢Áä∂Ê≥Å„ÅåÂ§±„Çè„Çå„Åæ„Åô„ÄÇ")) {
                localStorage.removeItem('nekoBattleProgress');
                stageProgress = {};
                 for (let i = 1; i <= MAX_GRADE; i++) {
                     stageProgress[i] = 0;
                 }
                alert("„Ç≤„Éº„É†„Éá„Éº„Çø„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü„ÄÇ");
                if (modeSelectionScreen.style.display === 'none' && gameScreen.style.display === 'none' && resultScreen.style.display === 'none') {
                     showStageSelection(currentGrade);
                }
            }
        }

        // --- „É¢„Éº„Éâ„Éª„Çπ„ÉÜ„Éº„Ç∏ÈÅ∏Êäû (Mode/Stage Selection) ---
        function showModeSelection() {
            modeSelectionScreen.style.display = 'block';
            stageSelectionScreen.style.display = 'none';
            gameScreen.style.display = 'none';
            resultScreen.style.display = 'none';
            stopTimer();
        }

        function selectMode(mode) {
            currentMode = mode;
            modeSelectionScreen.style.display = 'none';
            if (mode === 'grade') {
                showGradeSelection();
            } else if (mode === 'training') {
                startGame();
            }
        }

        function showGradeSelection() {
            stageSelectionScreen.innerHTML = '<h2>Â≠¶Âπ¥ÈÅ∏Êäû</h2>';
            for (let grade = 1; grade <= MAX_GRADE; grade++) {
                const button = document.createElement('button');
                button.textContent = `Â∞èÂ≠¶ ${grade}Âπ¥Áîü`;
                button.classList.add('mode-button');
                button.onclick = () => showStageSelection(grade);
                stageSelectionScreen.appendChild(button);
            }
             const backButton = document.createElement('button');
             backButton.textContent = '„É¢„Éº„ÉâÈÅ∏Êäû„Å´Êàª„Çã';
             backButton.onclick = showModeSelection;
             stageSelectionScreen.appendChild(backButton);
            stageSelectionScreen.style.display = 'block';
        }

        function showStageSelection(grade) {
            currentGrade = grade;
            stageSelectionScreen.innerHTML = `<h2>Â∞èÂ≠¶ ${grade}Âπ¥Áîü - „Çπ„ÉÜ„Éº„Ç∏ÈÅ∏Êäû</h2>`;
            const clearedUpTo = stageProgress[grade] || 0;

            for (let stage = 1; stage <= STAGES_PER_GRADE; stage++) {
                const button = document.createElement('button');
                button.textContent = `„Çπ„ÉÜ„Éº„Ç∏ ${stage}`;
                button.classList.add('stage-button');
                if (stage <= clearedUpTo + 1) {
                    button.disabled = false;
                    button.onclick = () => selectStage(stage);
                    if (stage <= clearedUpTo) {
                        button.textContent += " („ÇØ„É™„Ç¢)";
                        button.style.backgroundColor = '#81c784';
                    }
                } else {
                    button.disabled = true;
                    button.textContent += " („É≠„ÉÉ„ÇØ)";
                    button.style.backgroundColor = '#bdbdbd';
                }
                stageSelectionScreen.appendChild(button);
            }
            const backButton = document.createElement('button');
            backButton.textContent = 'Â≠¶Âπ¥ÈÅ∏Êäû„Å´Êàª„Çã';
            backButton.onclick = showGradeSelection;
            stageSelectionScreen.appendChild(backButton);
            stageSelectionScreen.style.display = 'block';
            modeSelectionScreen.style.display = 'none';
        }

        function selectStage(stage) {
            currentStage = stage;
            startGame();
        }

        // --- „Ç≤„Éº„É†ÂàùÊúüÂåñ„ÉªÈÄ≤Ë°å (Game Initialization & Progression) ---
        function startGame() {
            stageSelectionScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            resultScreen.style.display = 'none';

            playerHp = PLAYER_MAX_HP;
            score = 0;
            currentCombo = 0;
            updateScoreDisplay();
            updateComboDisplay();
            updatePlayerHpDisplay();

            if (currentMode === 'grade') {
                currentEnemyMaxHp = BASE_ENEMY_HP + (currentStage - 1) * HP_INCREASE_PER_STAGE;
                enemyHp = currentEnemyMaxHp;
                setupEnemy();
                generateProblems();
            } else {
                currentEnemyMaxHp = 9999;
                enemyHp = currentEnemyMaxHp;
                setupEnemy(true);
                trainingProblemsAnswered = 0;
                trainingCorrectAnswers = 0;
                generateTrainingProblem();
            }
            updateEnemyHpDisplay();
        }

        function restartGame() {
            startGame();
        }

        function nextStage() {
            if (currentMode === 'grade') {
                if (currentStage > (stageProgress[currentGrade] || 0)) {
                     stageProgress[currentGrade] = currentStage;
                     saveGameData();
                }
                if (currentStage < STAGES_PER_GRADE) {
                    currentStage++;
                    startGame();
                } else {
                    showResult(true, `Â∞èÂ≠¶ ${currentGrade}Âπ¥Áîü „ÇØ„É™„Ç¢ÔºÅ`);
                }
            } else {
                showModeSelection();
            }
        }

        // --- ÊïµË®≠ÂÆö (Enemy Setup) ---
        function setupEnemy(isTraining = false) {
            if (isTraining) {
                enemyName.textContent = "„Éà„É¨„Éº„Éã„É≥„Ç∞„ÉÄ„Éü„Éº";
                enemyIcon.textContent = "üéØ";
                enemyHpText.textContent = `HP: ‚àû/‚àû`;
                enemyHpBar.style.width = '100%';
                enemyHpBar.style.backgroundColor = '#4caf50';
                return;
            }
            const suitableEnemies = enemies.filter(e => e.minGrade <= currentGrade);
            const enemyData = suitableEnemies[Math.floor(Math.random() * suitableEnemies.length)];
            enemyName.textContent = enemyData.name;
            enemyIcon.textContent = enemyData.icon;
            updateEnemyHpDisplay();
        }

        // --- ÂïèÈ°åÁîüÊàê (Problem Generation) ---
        function generateProblems() {
            const problemType = getProblemTypeForGrade(currentGrade);
            const { question, answer } = generateMathProblem(problemType);
            currentQuestion = question;
            correctAnswer = answer;
            options = generateOptions(answer);
            displayProblemAndOptions();
            resetTimer();
        }

        function getProblemTypeForGrade(grade) {
            switch (grade) {
                case 1: return 'add_within_20';
                case 2: return 'subtract_within_100';
                case 3: return 'multiply_basic';
                case 4: return 'divide_basic';
                case 5: return 'mixed_easy';
                case 6: return 'mixed_all';
                default: return 'add_within_20';
            }
        }

        function generateMathProblem(type) {
            let num1, num2, question, answer;
            // (ÂïèÈ°åÁîüÊàê„É≠„Ç∏„ÉÉ„ÇØ„ÅØÂ§âÊõ¥„Å™„Åó - ÁúÅÁï•)
             switch (type) {
                case 'add_within_20':
                    num1 = Math.floor(Math.random() * 10) + 1;
                    num2 = Math.floor(Math.random() * 10) + 1;
                    question = `${num1} + ${num2} = ?`;
                    answer = num1 + num2;
                    break;
                case 'subtract_within_100':
                    num1 = Math.floor(Math.random() * 90) + 10; // 10-99
                    num2 = Math.floor(Math.random() * num1) + 1; // Ensure result is positive
                    if (Math.random() < 0.5) {
                        num2 = Math.floor(Math.random() * 9) + 1;
                        if (num1 < 10) num1 += 10;
                    } else {
                        num2 = Math.floor(Math.random() * (num1 - 5)) + 1;
                    }
                    num2 = Math.min(num2, num1 -1);
                    question = `${num1} - ${num2} = ?`;
                    answer = num1 - num2;
                    break;
                case 'multiply_basic':
                    num1 = Math.floor(Math.random() * 9) + 1;
                    num2 = Math.floor(Math.random() * 9) + 1;
                    question = `${num1} √ó ${num2} = ?`;
                    answer = num1 * num2;
                    break;
                case 'divide_basic':
                    answer = Math.floor(Math.random() * 9) + 1;
                    num2 = Math.floor(Math.random() * 9) + 1;
                    num1 = answer * num2;
                    question = `${num1} √∑ ${num2} = ?`;
                    break;
                 case 'mixed_easy': // +, -, *
                    const opTypeEasy = Math.floor(Math.random() * 3);
                    if (opTypeEasy === 0) {
                        num1 = Math.floor(Math.random() * 50) + 1;
                        num2 = Math.floor(Math.random() * 50) + 1;
                        question = `${num1} + ${num2} = ?`;
                        answer = num1 + num2;
                    } else if (opTypeEasy === 1) {
                        num1 = Math.floor(Math.random() * 90) + 10;
                        num2 = Math.floor(Math.random() * (num1 - 1)) + 1;
                        question = `${num1} - ${num2} = ?`;
                        answer = num1 - num2;
                    } else {
                        num1 = Math.floor(Math.random() * 9) + 1;
                        num2 = Math.floor(Math.random() * 9) + 1;
                        question = `${num1} √ó ${num2} = ?`;
                        answer = num1 * num2;
                    }
                    break;
                case 'mixed_all': // +, -, *, /
                     const opTypeAll = Math.floor(Math.random() * 4);
                     if (opTypeAll === 0) {
                         num1 = Math.floor(Math.random() * 100) + 1;
                         num2 = Math.floor(Math.random() * 100) + 1;
                         question = `${num1} + ${num2} = ?`;
                         answer = num1 + num2;
                     } else if (opTypeAll === 1) {
                         num1 = Math.floor(Math.random() * 150) + 10;
                         num2 = Math.floor(Math.random() * (num1 - 1)) + 1;
                         question = `${num1} - ${num2} = ?`;
                         answer = num1 - num2;
                     } else if (opTypeAll === 2) {
                         num1 = Math.floor(Math.random() * 12) + 1;
                         num2 = Math.floor(Math.random() * 12) + 1;
                         question = `${num1} √ó ${num2} = ?`;
                         answer = num1 * num2;
                     } else {
                         answer = Math.floor(Math.random() * 12) + 2;
                         num2 = Math.floor(Math.random() * 12) + 2;
                         num1 = answer * num2;
                         question = `${num1} √∑ ${num2} = ?`;
                     }
                     break;
                default:
                    num1 = Math.floor(Math.random() * 10) + 1;
                    num2 = Math.floor(Math.random() * 10) + 1;
                    question = `${num1} + ${num2} = ?`;
                    answer = num1 + num2;
            }
            return { question, answer };
        }

        function generateOptions(correctAnswer) {
            let generatedOptions = [correctAnswer];
            let attempts = 0; // ÁÑ°Èôê„É´„Éº„ÉóÈò≤Ê≠¢Áî®„Ç´„Ç¶„É≥„Çø„Éº
            while (generatedOptions.length < 4 && attempts < 20) {
                let range = Math.max(10, Math.abs(correctAnswer) * 0.5); // Á≠î„Åà„Å´Âøú„Åò„Å¶ÁØÑÂõ≤Ë™øÊï¥
                let offset = Math.floor(Math.random() * (range * 2 + 1)) - range;
                let dummyAnswer = correctAnswer + offset;
                 // Á≠î„Åà„Å®Âêå„Åò„ÄÅ„Åæ„Åü„ÅØË≤†„ÅÆÊï∞„ÄÅ„Åæ„Åü„ÅØÊó¢„Å´„É™„Çπ„Éà„Å´„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÜçÁîüÊàê
                if (dummyAnswer !== correctAnswer && dummyAnswer >= 0 && !generatedOptions.includes(dummyAnswer)) {
                    generatedOptions.push(dummyAnswer);
                }
                attempts++;
            }
             // „ÇÇ„Åó4„Å§ÁîüÊàê„Åß„Åç„Å™„Åã„Å£„ÅüÂ†¥ÂêàÔºàÁ≠î„Åà„Åå0„Å´Ëøë„ÅÑÂ†¥Âêà„Å™„Å©Ôºâ„ÄÅÂçòÁ¥î„Å™ÈÄ£Áï™„Å™„Å©„ÅßË£úÂÆå
             let fillValue = 0;
             while (generatedOptions.length < 4) {
                 if (!generatedOptions.includes(fillValue)) {
                     generatedOptions.push(fillValue);
                 }
                 fillValue++;
             }

            return generatedOptions.sort(() => Math.random() - 0.5);
        }

        function displayProblemAndOptions() {
            questionArea.textContent = currentQuestion;
            optionsArea.innerHTML = '';
            options.forEach(option => {
                const button = document.createElement('button');
                button.textContent = option;
                button.classList.add('option-button');
                button.onclick = () => handleAnswer(option);
                optionsArea.appendChild(button);
            });
        }

        function generateTrainingProblem() {
            const randomGrade = Math.floor(Math.random() * MAX_GRADE) + 1;
            const problemType = getProblemTypeForGrade(randomGrade);
            const { question, answer } = generateMathProblem(problemType);
            currentQuestion = `[„Éà„É¨ ${trainingProblemsAnswered + 1}/${TRAINING_PROBLEM_COUNT}] ${question}`;
            correctAnswer = answer;
            options = generateOptions(answer);
            displayProblemAndOptions();
            resetTimer();
        }

        // --- ÂõûÁ≠îÂá¶ÁêÜ (Answer Handling) ---

        // handleAnswer „Çí„É™„Éï„Ç°„ÇØ„Çø„É™„É≥„Ç∞ (Refactored handleAnswer)
        function handleAnswer(selectedAnswer) {
            stopTimer();
            const isCorrect = parseInt(selectedAnswer) === correctAnswer;

            if (isCorrect) {
                processCorrectAnswer();
            } else {
                processIncorrectAnswer();
            }

            updateAllDisplays(); // Update HP, combo, score displays
            checkGameStateAndProceed(); // Check win/loss/next question
        }

        // Ê≠£Ëß£ÊôÇ„ÅÆÂá¶ÁêÜ (Process correct answer)
        function processCorrectAnswer() {
            feedbackArea.textContent = "Ê≠£Ëß£ÔºÅ";
            feedbackArea.style.color = "green";
            currentCombo++;
            score += 10 + currentCombo;

            // „ÉÄ„É°„Éº„Ç∏Ë®àÁÆó
            let damage = BASE_DAMAGE * (1 + currentCombo * COMBO_BONUS_MULTIPLIER);
            let isCritical = false;
            if (Math.random() < CRITICAL_HIT_CHANCE) {
                damage *= CRITICAL_HIT_MULTIPLIER;
                isCritical = true;
                feedbackArea.textContent = "„ÇØ„É™„ÉÜ„Ç£„Ç´„É´„Éí„ÉÉ„ÉàÔºÅ"; // ‰∏äÊõ∏„Åç
            }
            damage = Math.round(damage);

            enemyHp -= damage;
            showDamageEffect(damage, isCritical, false); // Êïµ„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏Ë°®Á§∫

            if (currentMode === 'training') {
                trainingCorrectAnswers++;
            }
        }

        // ‰∏çÊ≠£Ëß£ÊôÇ„ÅÆÂá¶ÁêÜ (Process incorrect answer)
        function processIncorrectAnswer() {
            feedbackArea.textContent = `‰∏çÊ≠£Ëß£... Ê≠£Ëß£„ÅØ ${correctAnswer}`;
            feedbackArea.style.color = "red";
            currentCombo = 0;
            playerHp -= HP_PENALTY_WRONG;
            showDamageEffect(HP_PENALTY_WRONG, false, true); // „Éó„É¨„Ç§„É§„Éº„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏Ë°®Á§∫
        }

         // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇ„ÅÆÂá¶ÁêÜ (Process timeout) - handleTimeout„Åã„ÇâÂàÜÈõ¢
         function processTimeout() {
             feedbackArea.textContent = `ÊôÇÈñìÂàá„ÇåÔºÅ Ê≠£Ëß£„ÅØ ${correctAnswer}`;
             feedbackArea.style.color = "orange";
             currentCombo = 0;
             playerHp -= HP_PENALTY_TIMEOUT;
             showDamageEffect(HP_PENALTY_TIMEOUT, false, true); // „Éó„É¨„Ç§„É§„Éº„Å∏„ÅÆ„ÉÄ„É°„Éº„Ç∏Ë°®Á§∫
         }


        // „Ç≤„Éº„É†Áä∂ÊÖã„ÇíÁ¢∫Ë™ç„Åó„ÄÅÊ¨°„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Å∏ÈÄ≤„ÇÄ (Check game state and proceed)
        function checkGameStateAndProceed() {
            if (playerHp <= 0) {
                gameOver(false); // Player lost
            } else if (currentMode === 'grade' && enemyHp <= 0) {
                // Enemy defeated in grade mode
                feedbackArea.textContent = "Êïµ„ÇíÂÄí„Åó„ÅüÔºÅ";
                setTimeout(nextStage, ENEMY_DEFEATED_DELAY_MS);
            } else if (currentMode === 'training') {
                trainingProblemsAnswered++;
                if (trainingProblemsAnswered >= TRAINING_PROBLEM_COUNT) {
                    // Training finished
                    const accuracy = Math.round((trainingCorrectAnswers / TRAINING_PROBLEM_COUNT) * 100);
                    setTimeout(() => showResult(true, `„Éà„É¨„Éº„Éã„É≥„Ç∞ÂÆå‰∫ÜÔºÅ Ê≠£Ëß£Áéá: ${accuracy}%`), NEXT_ACTION_DELAY_MS);
                } else {
                    // Next training question
                    setTimeout(generateTrainingProblem, NEXT_ACTION_DELAY_MS);
                }
            } else {
                // Next question in grade mode
                setTimeout(generateProblems, NEXT_ACTION_DELAY_MS);
            }
        }

        // --- „Çø„Ç§„Éû„ÉºÈñ¢ÈÄ£ (Timer Functions) ---
        function startTimer() {
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimerDisplay(); // „Çø„Ç§„Éû„ÉºË°®Á§∫Êõ¥Êñ∞„ÇíÂà•Èñ¢Êï∞„Å´
                if (timeLeft <= 0) {
                    handleTimeout();
                }
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        function resetTimer() {
            stopTimer();
            timeLeft = TIME_LIMIT_SECONDS;
            updateTimerDisplay(); // ÂàùÊúüË°®Á§∫
            startTimer();
        }

        function handleTimeout() {
            stopTimer();
            processTimeout(); // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂá¶ÁêÜ„ÇíÂëº„Å≥Âá∫„Åó
            updateAllDisplays(); // Ë°®Á§∫Êõ¥Êñ∞
            checkGameStateAndProceed(); // „Ç≤„Éº„É†Áä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ„Å®ÈÄ≤Ë°å
        }

        // --- UIÊõ¥Êñ∞ (UI Updates) ---
         // „Åô„Åπ„Å¶„ÅÆ‰∏ªË¶Å„Å™Ë°®Á§∫„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞ (Function to update all main displays)
         function updateAllDisplays() {
            updatePlayerHpDisplay();
            updateEnemyHpDisplay();
            updateComboDisplay();
            updateScoreDisplay();
            // Timer display is updated separately by its interval/reset
         }

        function updatePlayerHpDisplay() {
            const percentage = Math.max(0, (playerHp / PLAYER_MAX_HP) * 100);
            playerHpBar.style.width = `${percentage}%`;
            playerHpText.textContent = `HP: ${Math.max(0, playerHp)}/${PLAYER_MAX_HP}`;
            playerHpBar.classList.toggle('low', percentage < 30);
        }

        function updateEnemyHpDisplay() {
            if (currentMode === 'training') {
                 enemyHpText.textContent = `HP: ‚àû/‚àû`;
                 enemyHpBar.style.width = '100%';
                 enemyHpBar.style.backgroundColor = '#4caf50';
                 return;
            }
            const percentage = Math.max(0, (enemyHp / currentEnemyMaxHp) * 100);
            enemyHpBar.style.width = `${percentage}%`;
            enemyHpText.textContent = `HP: ${Math.max(0, enemyHp)}/${currentEnemyMaxHp}`;
        }

        function updateComboDisplay() {
            comboArea.textContent = currentCombo > 1 ? `${currentCombo} „Ç≥„É≥„ÉúÔºÅ` : "";
        }

        function updateScoreDisplay() {
            scoreArea.textContent = `„Çπ„Ç≥„Ç¢: ${score}`;
        }

         function updateTimerDisplay() {
            timerArea.textContent = `„ÅÆ„Åì„ÇäÊôÇÈñì: ${timeLeft}Áßí`;
            if (timeLeft <= 3) {
                timerArea.style.color = 'red';
                timerArea.style.fontWeight = 'bold';
             } else {
                 timerArea.style.color = '#666';
                 timerArea.style.fontWeight = 'normal';
             }
         }

        function showDamageEffect(amount, isCritical = false, isPlayerDamage = false) {
            const damageText = document.createElement('div');
            damageText.textContent = `-${amount}`;
            damageText.classList.add('damage-effect');
            if (isCritical) {
                damageText.classList.add('critical-damage');
            }
            // „Çø„Éº„Ç≤„ÉÉ„ÉàË¶ÅÁ¥†„ÅÆÊ±∫ÂÆöÔºàÂ§âÊõ¥„Å™„ÅóÔºâ
            // const targetElement = isPlayerDamage ? document.getElementById('player') : document.getElementById('enemy');
            gameContainer.appendChild(damageText); // gameContainer„Å´ËøΩÂä†ÔºàÂ§âÊõ¥„Å™„ÅóÔºâ
            damageText.addEventListener('animationend', () => {
                damageText.remove();
            });
        }

        // --- „Ç≤„Éº„É†ÁµÇ‰∫ÜÂá¶ÁêÜ (Game End Handling) ---
        function gameOver(isWin) {
            stopTimer();
            gameScreen.style.display = 'none';
            resultScreen.style.display = 'block';

            if (isWin) {
                resultTitle.textContent = "ÂãùÂà©ÔºÅ";
                resultMessage.textContent = currentMode === 'grade' ? `„Çπ„ÉÜ„Éº„Ç∏ ${currentStage} „ÇØ„É™„Ç¢ÔºÅ` : "„Éà„É¨„Éº„Éã„É≥„Ç∞ÂÆå‰∫ÜÔºÅ"; // „É°„ÉÉ„Çª„Éº„Ç∏„ÅØ showResult „ÅßË®≠ÂÆö„Åï„Çå„Çã„Åì„Å®„ÅåÂ§ö„ÅÑ
                resultScore.textContent = `ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}`;
                if (currentMode === 'grade' && currentStage > (stageProgress[currentGrade] || 0)) {
                     stageProgress[currentGrade] = currentStage;
                     saveGameData();
                 }
            } else {
                resultTitle.textContent = "„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº...";
                resultMessage.textContent = playerHp <= 0 ? "HP„Åå„Çº„É≠„Å´„Å™„Å£„Åü..." : "ÊÆãÂøµÔºÅ";
                resultScore.textContent = `ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: ${score}`;
            }
        }

         function showResult(isSuccess, message) {
             stopTimer();
             gameScreen.style.display = 'none';
             resultScreen.style.display = 'block';
             resultTitle.textContent = isSuccess ? "ÊàêÂäüÔºÅ" : "Â§±Êïó...";
             resultMessage.textContent = message;
             resultScore.textContent = `„Çπ„Ç≥„Ç¢: ${score}`;

             if (isSuccess && currentMode === 'grade' && currentStage > (stageProgress[currentGrade] || 0)) {
                  stageProgress[currentGrade] = currentStage;
                  saveGameData();
              }
         }

        // --- ÂàùÊúüÂåñ (Initialization) ---
        window.onload = () => {
            loadGameData();
            showModeSelection();
            bgmToggle.textContent = isBgmPlaying ? 'üîä' : 'üîá';
        };

    </script>
</body>
</html>
